// SCRAPED FROM: $api_index
// BY: Capt. Micro
// SCRIPT: End of file
 
/*
    ATOM_BASIC_INFORMATION (STRUCT)
    UsageCount
     Internal Atom counter state. This value increments at every NtAddAtom call for current Atom, and it's decremented on every NtDeleteAtom function call.
    Flags
     (?), Only lowest bit is used.
    NameLength
     Size of Name array, in bytes.
    Name[1]
     Atom name.
*/
typedef struct _ATOM_BASIC_INFORMATION {
    USHORT UsageCount;
    USHORT Flags;
    USHORT NameLength;
    WCHAR Name[1];
} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;
 
/*
    ATOM_INFORMATION_CLASS (ENUM)
*/
typedef enum _ATOM_INFORMATION_CLASS {
    AtomBasicInformation,
    AtomTableInformation
} ATOM_INFORMATION_CLASS, *PATOM_INFORMATION_CLASS;
 
/*
    ATOM_TABLE_INFORMATION (STRUCT)
    NumberOfAtoms
     Number of members in Atoms array.
    Atoms[1]
     Array of Global Atoms.
*/
typedef struct _ATOM_TABLE_INFORMATION {
    ULONG NumberOfAtoms;
    RTL_ATOM Atoms[1];
} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;
 
/*
    DbgPrint (FUNCTION)
    INFO-0
     Function works like a normal C printf routine, but result is streamed to debug output.
*/
typedef NTSTATUS (NTAPI *_DbgPrint)( IN LPCSTR Format, ... );
 
/*
    DBG_STATE (ENUM)
*/
typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;
 
/*
    EVENT_BASIC_INFORMATION (STRUCT)
    INFO-0
     This structure is used with EventBasicInformation information class as a result of call NtQueryEvent.
    EventType
     Type of Event Object. Can be SynchronizationEvent or NotificationEvent. See EVENT_TYPE for details.
    EventState
     Current state of Event Object.
*/
typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;
 
/*
    EVENT_INFORMATION_CLASS (ENUM)
*/
typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS, *PEVENT_INFORMATION_CLASS;
 
/*
    EVENT_TYPE (ENUM)
*/
typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE, *PEVENT_TYPE;
 
/*
    FILE_BASIC_INFORMATION (STRUCT)
    CreationTime
     Time of file creation, in 100-ns units.
    LastAccessTime
     Time of last open operation, in 100-ns units.
    LastWriteTime
     Time of last write operation, in 100-ns units.
    ChangeTime
     Time of any last change, in 100-ns units.
    FileAttributes
     File attributes. See NtCreateFile for possibilities.
*/
typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
 
/*
    FILE_BOTH_DIR_INFORMATION (STRUCT)
    NextEntryOffset
     Offset (in bytes) of next FILE_BOTH_DIR_INFORMATION structure placed in result buffer. If there's no more entries, NextEntryOffset is set to zero.
    FileIndex
     File index value, or zero, if directory indexing is not avaiable.
    CreationTime
     Time of object creation;
    LastAccessTime
     Last access time. Means time when last open operation was performed.
    LastWriteTime
     Time of last write data.
    ChangeTime
     Time of last change.
    EndOfFile
     Specify length of file, in bytes.
    AllocationSize
     Specify real size of file on device. It must be equal or greater to EndOfFile member.
    FileAttributes
     Attributes of file.
    FileNameLength
     Length of FileName array, in bytes.
    EaSize
     Size of Extended Attributes associated with file. See also FILE_EA_INFORMATION structure.
    ShortNameLength
     Length ShortName array, in bytes.
    ShortName[12]
     Alternate file name, in UNICODE format. Empty string means:
         Primary name is compatible with 8DOT3 (MS DOS) standart, and there's no reason to set the same name twice;
         File system don't improve short names;
    FileName[1]
     UNICODE string specifing file name.
*/
typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    BYTE ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;
 
/*
    FILE_DIRECTORY_INFORMATION (STRUCT)
    NextEntryOffset
     Offset (in bytes) of next FILE_DIRECTORY_INFORMATION structure placed in result buffer. If there's no more entries, NextEntryOffset is set to zero.
    FileIndex
     File index value, or zero, if directory indexing is not avaiable.
    CreationTime
     Time of object creation;
    LastAccessTime
     Last access time. Means time when last open operation was performed.
    LastWriteTime
     Time of last write data.
    ChangeTime
     Time of last change.
    EndOfFile
     Specify length of file, in bytes.
    AllocationSize
     Specify real size of file on device. It must be equal or greater to EndOfFile member.
    FileAttributes
     Attributes of file.
    FileNameLength
     Length of FileName array, in bytes.
    FileName[1]
     UNICODE string specifing file name.
*/
typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
 
/*
    FILE_FS_ATTRIBUTE_INFORMATION (STRUCT)
    INFO-0
     FILE_FS_ATTRIBUTE_INFORMATION is output buffer in a call to NtQueryVolumeInformationFile function with FileFsAttributeInformation information class.
    MaximumComponentNameLength
     Maximum length of file name on specified device.
    FileSystemNameLength
     Length of FileSystemName array, in bytes.
    FileSystemName[1]
     Name of File System on specified device (ex. "NTFS").
*/
typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;
 
/*
    FILE_FS_CONTROL_INFORMATION (STRUCT)
    INFO-0
     Structure FILE_FS_CONTROL_INFORMATION is user as input and output buffers in calls to NtQueryVolumeInformationFile and NtSetVolumeInformationFile with information class set to FileFsControlInformation.
    INFO-1
     FreeSpaceStartFiltering
    INFO-2
     FreeSpaceThreshold
    INFO-3
     FreeSpaceStopFiltering
    INFO-4
     DefaultQuotaThreshold
    INFO-5
     DefaultQuotaLimit
    INFO-6
     FileSystemControlFlags
*/
typedef struct _FILE_FS_CONTROL_INFORMATION {
    LARGE_INTEGER FreeSpaceStartFiltering;
    LARGE_INTEGER FreeSpaceThreshold;
    LARGE_INTEGER FreeSpaceStopFiltering;
    LARGE_INTEGER DefaultQuotaThreshold;
    LARGE_INTEGER DefaultQuotaLimit;
    ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;
 
/*
    FILE_FS_DEVICE_INFORMATION (STRUCT)
    DeviceType
     Numeric device types are defined in &lt;ntddk.h&gt; as FILE_DEVICE_* precompiler definitions.
    Characteristics
     Or-ed bit mask of device characteristic. Can be one of:
        FILE_REMOVABLE_MEDIA          
        FILE_READ_ONLY_DEVICE
*/
typedef struct _FILE_FS_DEVICE_INFORMATION {
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;
 
/*
    FILE_FS_LABEL_INFORMATION (STRUCT)
    VolumeLabelLength
     Length of VolumeLabel array, in bytes.
    VolumeLabel[1]
     Label for specified volume.
*/
typedef struct _FILE_FS_LABEL_INFORMATION {
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;
 
/*
    FILE_FS_SIZE_INFORMATION (STRUCT)
    INFO-0
     Structure provides detailed information about volume physical size. Is returned in call to NtQueryVolumeInformationFile with FileFsSizeInformation information class.
    INFO-1
     TotalAllocationUnits
    INFO-2
     AvailableAllocationUnits
    INFO-3
     SectorsPerAllocationUnit
    INFO-4
     BytesPerSector
*/
typedef struct _FILE_FS_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;
 
/*
    FILE_FS_VOLUME_INFORMATION (STRUCT)
    VolumeCreationTime
     It means time of last Volume Formating Process.
    VolumeSerialNumber
     Serial number of volume, associated in Volume Formating Process.
    VolumeLabelLength
     Length of VolumeLabel array, in bytes.
    SupportsObjects
     If TRUE, Object Files can be stored on specified volume.
    VolumeLabel[1]
     Name of volume. Can be set with FileFsLabelInformation.
*/
typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;
 
/*
    FILE_FULL_DIR_INFORMATION (STRUCT)
    NextEntryOffset
     Offset (in bytes) of next FILE_FULL_DIR_INFORMATION structure placed in result buffer. If there's no more entries, NextEntryOffset is set to zero.
    FileIndex
     File index value, or zero, if directory indexing is not avaiable.
    CreationTime
     Time of object creation;
    LastAccessTime
     Last access time. Means time when last open operation was performed.
    LastWriteTime
     Time of last write data.
    ChangeTime
     Time of last change.
    EndOfFile
     Specify length of file, in bytes.
    AllocationSize
     Specify real size of file on device. It must be equal or greater to EndOfFile member.
    FileAttributes
     Attributes of file.
    FileNameLength
     Length of FileName array, in bytes.
    EaSize
     Size of Extended Attributes associated with file. See also FILE_EA_INFORMATION structure.
    FileName[1]
     UNICODE string specifing file name.
*/
typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;
 
/*
    FILE_FULL_EA_INFORMATION (STRUCT)
    INFO-0
     Structure FILE_FULL_EA_INFORMATION is also defined in Win2000 DDK.
*/
typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    BYTE Flags;
    BYTE EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;
 
/*
    FILE_GET_EA_INFORMATION (STRUCT)
    INFO-0
     Structure FILE_GET_EA_INFORMATION is used in a call to NtQueryEaFile function. See FILE_FULL_EA_INFORMATION for detailed information about EA.
    NextEntryOffset
     Relative offset for next FILE_GET_EA_INFORMATION structure in buffer.
    EaNameLength
     Length of EA name, in bytes (without leading zero).
    EaName[1]
     ASCIIZ name of EA, case insensitive.
*/
typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    BYTE EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;
 
/*
    FILE_INFORMATION_CLASS (ENUM)
*/
typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation=1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileCopyOnWriteInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileObjectIdInformation,
    FileTrackingInformation,
    FileOleDirectoryInformation,
    FileContentIndexInformation,
    FileInheritContentIndexInformation,
    FileOleInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
 
/*
    FILE_INTERNAL_INFORMATION (STRUCT)
    IndexNumber
     File indentifier, unique for file's device.
*/
typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;
 
/*
    FILE_LINK_INFORMATION (STRUCT)
    ReplaceIfExists
     If set, and destination object already exists, it will be replaced with newly created link.
    RootDirectory
     HANDLE to File Object specyfing directory where link should be placed. Can be NULL if FileName parameter contains full path.
    FileNameLength
     Length of FileName array, in bytes.
    FileName[1]
     UNICODE string specyfing name of link and optionally with path (see description of RootDirectory).
*/
typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;
 
/*
    FILE_NAMES_INFORMATION (STRUCT)
    NextEntryOffset
     Offset (in bytes) of next FILE_NAMES_INFORMATION entry, or zero if last.
    FileIndex
     Index of file, or zero if Directory Indexing is disabled.
    FileNameLength
     Length of FileName array, in bytes.
    FileName[1]
     Name of file, in UNICODE format.
*/
typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;
 
/*
    FILE_NAME_INFORMATION (STRUCT)
    FileNameLength
     Length of FileName, in bytes.
    FileName[1]
     UNICODE name of file. If caller query about FileNameInformation, FileName additionally contains path to file, and begins with '/' (full path to file relative to device).
*/
typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;
 
/*
    FILE_NETWORK_OPEN_INFORMATION (STRUCT)
    CreationTime
     Indicates time of file creation.
    LastAccessTime
     Time of last open file.
    LastWriteTime
     Time of last write operation.
    ChangeTime
     Time of any last change.
    AllocationSize
     Number of bytes that file use on storage, equal or greater to EndOfFile.
    EndOfFile
     Length of file, in bytes.
    FileAttributes
     File attributes.
*/
typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
    ULONG Unknown;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;
 
/*
    FILE_NOTIFY_INFORMATION (STRUCT)
    INFO-0
     Only some of notification reasons can be readed from Action member. In most cases is contains FILE_ACTION_MODIFIED value, and user must check sort of notitication manually.
*/
typedef struct _FILE_NOTIFY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG Action;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;
 
/*
    FILE_RENAME_INFORMATION (STRUCT)
    ReplaceIfExists
     If set, and file with the same name as destination exist, it will be replaced. If no, STATUS_OBJECT_NAME_COLLISION is returned.
    RootDirectory
     Optional HANDLE to parent directory for destination file.
    FileNameLength
     Length of FileName array, in bytes.
    FileName[1]
     UNICODE string specifing destination file name. If RootDirectory is NULL, it must contains full system path, or only destination file name for in-place rename operation.
*/
typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;
 
/*
    FS_INFORMATION_CLASS (ENUM)
*/
typedef enum _FS_INFORMATION_CLASS {
    FileFsVolumeInformation=1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
 
/*
    HARDERROR_MSG (STRUCT)
    INFO-0
     Structure HARDERROR_MSG is send to LPC server in a result of call NtRaiseHardError. Most of stucture's members are  the same as parameters specified in this call.
    LpcMessageHeader
     Message header - see LPC_MESSAGE description.
    ErrorStatus
     Error code.
    ErrorTime
     Time when error was signaled.
    ResponseOption
     See HARDERROR_RESPONSE_OPTION for possible values.
    Response
     See HARDERROR_RESPONSE for possible values.
    NumberOfParameters
     Number of parameters in Parameters array. Maximum parameters number is defined as:
    UnicodeStringParameterMask
     Pointer to UNICODE_STRING in port's client address space
    Parameters[MAXIMUM_HARDERROR_PARAMETERS]
     Array of DWORD parameters.
*/
typedef struct _HARDERROR_MSG {
    LPC_MESSAGE LpcMessageHeader;
    NTSTATUS ErrorStatus;
    LARGE_INTEGER ErrorTime;
    HARDERROR_RESPONSE_OPTION ResponseOption;
    HARDERROR_RESPONSE Response;
    ULONG NumberOfParameters;
    PVOID UnicodeStringParameterMask;
    ULONG Parameters[MAXIMUM_HARDERROR_PARAMETERS];
} HARDERROR_MSG, *PHARDERROR_MSG;
 
/*
    HARDERROR_RESPONSE (ENUM)
*/
typedef enum _HARDERROR_RESPONSE {
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes
} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;
 
/*
    HARDERROR_RESPONSE_OPTION (ENUM)
*/
typedef enum _HARDERROR_RESPONSE_OPTION {
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem
} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;
 
/*
    INITIAL_TEB (STRUCT)
    StackBase
     DIV CLASS="reg">
    StackLimit
     DIV CLASS="reg">
    StackCommit
     DIV CLASS="reg">
    StackCommitMax
     DIV CLASS="reg">
    StackReserved
     DIV CLASS="reg">
*/
typedef struct _INITIAL_TEB {
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackCommit;
    PVOID StackCommitMax;
    PVOID StackReserved;
} INITIAL_TEB, *PINITIAL_TEB;
 
/*
    IO_COMPLETION_BASIC_INFORMATION (STRUCT)
    Depth
     Number of currently pending file operations for specified IO Completion Object.
*/
typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    ULONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;
 
/*
    IO_COMPLETION_INFORMATION_CLASS (ENUM)
*/
typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS, *PIO_COMPLETION_INFORMATION_CLASS;
 
/*
    KEY_MULTIPLE_VALUE_INFORMATION (STRUCT)
    ValueName
     Pointer to UNICODE_STRING structure containing value name. If specified value not exist, function fails.
    DataLength
     Length of value's data, in bytes.
    DataOffset
     Offset in output buffer (declared in NtQueryMultipleValueKey) to value's data.
    Type
     Type of queried value.
*/
typedef struct _KEY_MULTIPLE_VALUE_INFORMATION {
    PUNICODE_STRING ValueName;
    ULONG DataLength;
    ULONG DataOffset;
    ULONG Type;
} KEY_MULTIPLE_VALUE_INFORMATION, *PKEY_MULTIPLE_VALUE_INFORMATION;
 
/*
    KiUserApcDispatcher (FUNCTION)
    KiUserApcDispatcher isn't standard ntdll function. It's used by kernel to process APC queue for calling thread.
     Five paraters I defined only for compatibility with ntdll.lib export (_KiUserApcDispatcher@20). Function first execute  code placed after call, and next calls NtContinue with CONTEXT specified at 4 parameter position (Warning: Not pointer to CONTEXT, but CONTEXT body must be stored on stack).
*/
typedef VOID (NTAPI *_KiUserApcDispatcher)( IN PVOID Unused1, IN PVOID Unused2, IN PVOID Unused3, IN PVOID ContextStart, IN PVOID ContextBody );
 
/*
    KPROFILE_SOURCE (ENUM)
*/
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE, *PKPROFILE_SOURCE;
 
/*
    LdrGetDllHandle (FUNCTION)
    ModuleFileName
     Path to file + Dll name, in NT directory format.
    pHModule
     Pointer to received HMODULE. See LdrLoadDll for more info.
*/
typedef NTSTATUS (NTAPI *_LdrGetDllHandle)( IN PWORD pwPath OPTIONAL, IN PVOID Unused OPTIONAL, IN PUNICODE_STRING ModuleFileName, OUT PHANDLE pHModule );
 
/*
    LdrGetProcedureAddress (FUNCTION)
    FunctionName
     Is optional, but you must declare one of FunctionName or Oridinal. In Microsoft concept, you should use both parameters,
*/
typedef NTSTATUS (NTAPI *_LdrGetProcedureAddress)( IN HMODULE ModuleHandle, IN PANSI_STRING FunctionName OPTIONAL, IN WORD Oridinal OPTIONAL, OUT PVOID *FunctionAddress );
 
/*
    LdrLoadDll (FUNCTION)
    Flags
     See WINAPI LoadLibraryEx for possibbilitied flags.
    ModuleHandle
     Address of MZ header in virtual memory of caller's process.
*/
typedef NTSTATUS (NTAPI *_LdrLoadDll)( IN PWCHAR PathToFile OPTIONAL, IN ULONG Flags OPTIONAL, IN PUNICODE_STRING ModuleFileName, OUT PHANDLE ModuleHandle );
 
/*
    LdrQueryProcessModuleInformation (FUNCTION)
    INFO-0
     Use for enumerate modules loaded with current process.
    BufferSize
     Required minimum size is sizeof(SYSTEM_MODULE_INFORMATION) (4 bytes).
*/
typedef NTSTATUS (NTAPI *_LdrQueryProcessModuleInformation)( OUT PSYSTEM_MODULE_INFORMATION SystemModuleInformationBuffer, IN ULONG BufferSize, OUT PULONG RequiredSize OPTIONAL );
 
/*
    LdrShutdownProcess (FUNCTION)
    INFO-0
     Kernel32.dll use this after call to NtTerminateProcess.
*/
typedef VOID (NTAPI *_LdrShutdownProcess)();
 
/*
    LdrShutdownThread (FUNCTION)
    INFO-0
*/
typedef VOID (NTAPI *_LdrShutdownThread)();
 
/*
    LdrUnloadDll (FUNCTION)
    ModuleHandle
     In fact, ModuleHandle is virtual address of loaded module, not a typical HANDLE to object.
*/
typedef NTSTATUS (NTAPI *_LdrUnloadDll)( IN HANDLE ModuleHandle );
 
/*
    LDR_MODULE (STRUCT)
    InLoadOrderModuleList
     ointers to previous and next LDR_MODULE in load order.
    InMemoryOrderModuleList
     ointers to previous and next LDR_MODULE in memory placement order.
    InInitializationOrderModuleList
     ointers to previous and next LDR_MODULE in initialization order.
    BaseAddress
     odule base address known also as HMODULE.
    EntryPoint
     odule entry point (address of initialization procedure).
    SizeOfImage
     um of all image's sections placed in memory. Rounded up to 4Kb (page size).
    FullDllName
     ath and name of module.
    BaseDllName
     odule name only.
    INFO-8
     Flags
    INFO-9
     LoadCount
    INFO-10
     TlsIndex
    HashTableEntry
     B>LIST_ENTRY contains pointer to LdrpHashTable. Both prev and next values are the same.
    INFO-12
     TimeDateStamp
*/
typedef struct _LDR_MODULE {
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID BaseAddress;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    SHORT LoadCount;
    SHORT TlsIndex;
    LIST_ENTRY HashTableEntry;
    ULONG TimeDateStamp;
} LDR_MODULE, *PLDR_MODULE;
 
/*
    LPC_MESSAGE (STRUCT)
    DataLength
     Length of additional data in message. Maximum length of data is 0x130 bytes.
    Length
     Length of message, including header. Maximum value is 0x148 bytes length.
    MessageType
     Type of message. This field is filled by system in message transfer process. Can be one of following:
        LPC_REQUEST                            
        LPC_REPLY                              
    INFO-4
     DataInfoOffset
    ClientId
     Port's client unique identifier.
    MessageId
     System set this field to actual value of incremental message counter.
    INFO-7
     CallbackId
*/
typedef struct _LPC_MESSAGE {
    USHORT DataLength;
    USHORT Length;
    USHORT MessageType;
    USHORT DataInfoOffset;
    CLIENT_ID ClientId;
    ULONG MessageId;
    ULONG CallbackId;
} LPC_MESSAGE, *PLPC_MESSAGE;
 
/*
    LPC_SECTION_MEMORY (STRUCT)
    INFO-0
*/
typedef struct _LPC_SECTION_MEMORY {
    ULONG Length;
    ULONG ViewSize;
    PVOID ViewBase;
} LPC_SECTION_MEMORY, *PLPC_SECTION_MEMORY;
 
/*
    LPC_SECTION_OWNER_MEMORY (STRUCT)
    INFO-0
     This structure is used by LPC connection functions by Section Object creator side (whatever it is client of port or server). See LPC_SECTION_MEMORY for more information.
    Length
     Length of structure.
    SectionHandle
     HANDLE to SectionObject mapped on both sides of LPC connection.
    INFO-3
     OffsetInSection
    ViewSize
     Receives size of mapped window.
    ViewBase
     Receives base address of mapped window.
    OtherSideViewBase
     Receives base address of mapped window for other LPC connection side.
*/
typedef struct _LPC_SECTION_OWNER_MEMORY {
    ULONG Length;
    HANDLE SectionHandle;
    ULONG OffsetInSection;
    ULONG ViewSize;
    PVOID ViewBase;
    PVOID OtherSideViewBase;
} LPC_SECTION_OWNER_MEMORY, *PLPC_SECTION_OWNER_MEMORY;
 
/*
    LPC_TERMINATION_MESSAGE (STRUCT)
    INFO-0
     LPC_TERMINATION_MESSAGE is send to LPC server process when thread is terminating. Thread must be registered for inform server process by call NtRegisterThreadTerminatePort.
    INFO-1
     This message type is also send when LPC client close connection to server's port.
    Header
     Header.MessageType is LPC_CLIENT_DIED when thread terminate.
    INFO-3
     See LPC_MESSAGE for details.
    CreationTime
     Time of thread creation or time of connection begin.
*/
typedef struct _LPC_TERMINATION_MESSAGE {
    LPC_MESSAGE_HEADER Header;
    LARGE_INTEGER CreationTime;
} LPC_TERMINATION_MESSAGE, *PLPC_TERMINATION_MESSAGE;
 
/*
    MEMORY_BASIC_INFORMATION (STRUCT)
    BaseAddress
     Address of queried memory page.
    AllocationBase
     Base address of allocation. It's different (typically less) to BaseAddress when user allocate more then one page length memory block, and change attributes of a part of allocated block.
    AllocationProtect
     Access type on memory allocation. Can be one or combination of following attributes:
    INFO-3
        PAGE_NOACCESS   PAGE_READONLY   PAGE_READWRITE  PAGE_WRITECOPY  PAGE_EXECUTE    PAGE_EXECUTE_READ       PAGE_EXECUTE_READWRITE  PAGE_EXECUTE_WRITECOPY  PAGE_GUARD      PAGE_NOCACHE    PAGE_WRITECOMBINE
    RegionSize
     Size of queried region, in bytes.
    State
     State of memory block. Can be one of:
    INFO-6
        MEM_RESERVE     MEM_COMMIT      MEM_FREE
    Protect
     Current protection of queried memory block. Can be one or combination of values listed for AllocationProtect member.
    Type
     Type of queried memory block. Can be one of:
    INFO-9
        MEM_PRIVATE - Queried block was allocated by call NtAllocateVirtualMemory,      MEM_MAPPED - Queried block is memory mapped Section Object,     SEC_IMAGE - Queried block is Section Object representing executable image file in memory.
*/
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    ULONG AllocationProtect;
    ULONG RegionSize;
    ULONG State;
    ULONG Protect;
    ULONG Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
 
/*
    MEMORY_INFORMATION_CLASS (ENUM)
*/
typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;
 
/*
    MUTANT_BASIC_INFORMATION (STRUCT)
    INFO-0
     Use MUTANT_BASIC_INFORMATION as a buffer in NtQueryMutant call.
    INFO-1
     <HR WIDTH="40%">
    CurrentCount
     f CurrentCount is less than zero, mutant is signaled.
    OwnedByCaller
     t's TRUE if mutant is signaled by caller's thread.
    AbandonedState
     s set when thread terminates without call NtReleaseMutant.
*/
typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;
 
/*
    NtAcceptConnectPort (FUNCTION)
    INFO-0
     This function returns HANDLE to newly created Port Object. All other LPC functions for currently accepted connection should use this HANDLE, not a base named port HANDLE created with NtCreatePort.
*/
typedef NTSTATUS (NTAPI *_NtAcceptConnectPort)( OUT PHANDLE ServerPortHandle, IN HANDLE AlternativeReceivePortHandle OPTIONAL, IN PLPC_MESSAGE ConnectionReply, IN BOOLEAN AcceptConnection, IN OUT PLPC_SECTION_OWNER_MEMORY ServerSharedMemory OPTIONAL, OUT PLPC_SECTION_MEMORY ClientSharedMemory OPTIONAL );
 
/*
    NtAccessCheck (FUNCTION)
    SecurityDescriptor
     Pointer to SECURITY_DESCRIPTOR structure.
    ClientToken
     HANDLE to client's Token Object opened with TOKEN_QUERY access.
    DesiredAccess
     ACCESS_MASK required by client.
    GenericMapping
     Pointer to GENERIC_MAPPING structure. Caller can take it in a call to NtQueryObject.
    RequiredPrivilegesBuffer
     Function fills this buffer with structure PRIVILEGE_SET contains required privileges.
    BufferLength
     Pointer to ULONG value. On input this value means size of RequiredPrivilegesBuffer buffer. If buffer was to small, required buffer size is avaiable on output.
    GrantedAccess
     Pointer to ACCESS_MASK value receiving granted access for object.
    AccessStatus
     Result of access check, in typical NTSTATUS format.
*/
typedef NTSTATUS (NTAPI *_NtAccessCheck)( IN PSECURITY_DESCRIPTOR SecurityDescriptor, IN HANDLE ClientToken, IN ACCESS_MASK DesiredAccess, IN PGENERIC_MAPPING GenericMapping OPTIONAL, OUT PPRIVILEGE_SET RequiredPrivilegesBuffer, IN OUT PULONG BufferLength, OUT PACCESS_MASK GrantedAccess, OUT PNTSTATUS AccessStatus );
 
/*
    NtAccessCheckAndAuditAlarm (FUNCTION)
    ObjectHandle
     Can be any valid HANDLE to object, or NULL.
    SecurityDescriptor
     Pointer to "Absolute" SECURITY_DESCRIPTOR structure.
    GenericMapping
     Pointer to GENERIC_MAPPING structure valid for object specified above as ObjectHandle parameter.
    GrantedAccess
     Pointer to ACCESS_MASK value (?).
    AccessStatus
     Pointer to NTSTATUS value (?).
    GenerateOnClose
     Pointer to BOOLEAN value (?).
*/
typedef NTSTATUS (NTAPI *_NtAccessCheckAndAuditAlarm)( IN PUNICODE_STRING SubsystemName OPTIONAL, IN HANDLE ObjectHandle OPTIONAL, IN PUNICODE_STRING ObjectTypeName OPTIONAL, IN PUNICODE_STRING ObjectName OPTIONAL, IN PSECURITY_DESCRIPTOR SecurityDescriptor, IN ACCESS_MASK DesiredAccess, IN PGENERIC_MAPPING GenericMapping, IN BOOLEAN ObjectCreation, OUT PULONG GrantedAccess, OUT PULONG AccessStatus, OUT PBOOLEAN GenerateOnClose );
 
/*
    NtAddAtom (FUNCTION)
    AtomName
     UNICODE Atom name.
    Atom
     Result of call - pointer to RTL_ATOM.
*/
typedef NTSTATUS (NTAPI *_NtAddAtom)( IN PWCHAR AtomName, OUT PRTL_ATOM Atom );
 
/*
    NtAdjustGroupsToken (FUNCTION)
    TokenHandle
     HANDLE to Token Object opened with TOKEN_ADJUST_GROUPS access.
    ResetToDefault
     If set, groups are reset to token's defaults. In this case all other parameters are ignored.
    TokenGroups
     Pointer to TOKEN_GROUPS structure containing groups to modify.
    PreviousGroupsLength
     Specifies length of PreviousGroups buffer, in bytes.
    PreviousGroups
     Optionally pointer to TOKEN_GROUPS buffer receiving information about modified groups before modification begins.
    RequiredLength
     If PreviousGroups parameter is specified, and PreviousGroupsLength is to small, this value receives required length of buffer, in bytes.
*/
typedef NTSTATUS (NTAPI *_NtAdjustGroupsToken)( IN HANDLE TokenHandle, IN BOOLEAN ResetToDefault, IN PTOKEN_GROUPS TokenGroups, IN ULONG PreviousGroupsLength, OUT PTOKEN_GROUPS PreviousGroups OPTIONAL, OUT PULONG RequiredLength OPTIONAL );
 
/*
    NtAdjustPrivilegesToken (FUNCTION)
    TokenHandle
     HANDLE to Token Object opened with TOKEN_ADJUST_PRIVILEGES access. If PreviousPrivileges parameter is non-NULL, also TOKEN_QUERY access is required.
    DisableAllPrivileges
     If set, all accessable privileges are disabled, and rest of parameters below are ignored.
    TokenPrivileges
     Pointer to TOKEN_PRIVILEGES structure containing array of privileges to adjust.
    PreviousPrivilegesLength
     Length of PreviousPrivileges buffer, in bytes.
    PreviousPrivileges
     Optionally pointer to TOKEN_PRIVILEGES structure filled by function with previous state of privileges specified by TokenPrivileges array.
    RequiredLength
     If PreviousPrivileges buffer was to small, this parameter point to required size.
*/
typedef NTSTATUS (NTAPI *_NtAdjustPrivilegesToken)( IN HANDLE TokenHandle, IN BOOLEAN DisableAllPrivileges, IN PTOKEN_PRIVILEGES TokenPrivileges, IN ULONG PreviousPrivilegesLength, OUT PTOKEN_PRIVILEGES PreviousPrivileges OPTIONAL, OUT PULONG RequiredLength OPTIONAL );
 
/*
    NtAlertResumeThread (FUNCTION)
    ThreadHandle
     andle to thread object.
    SuspendCount
     eturns number of suspend request for thread ThreadHandle before call NtAlertResumeThread. If this number is 0,
    INFO-2
     Difference between AlertResumeThread and ResumeThread it's the first one sets Thread Object to alerted state (so before thread will continue execution, all APC will be executed).
*/
typedef NTSTATUS (NTAPI *_NtAlertResumeThread)( IN HANDLE ThreadHandle, OUT PULONG SuspendCount );
 
/*
    NtAlertThread (FUNCTION)
    ThreadHandle
     andle to opened Thread Object.
    INFO-1
     <HR WIDTH="40%">
    INFO-2
     NtAlertThread puts specified thread in alerted state.
*/
typedef NTSTATUS (NTAPI *_NtAlertThread)( IN HANDLE ThreadHandle );
 
/*
    NtAllocateLocallyUniqueId (FUNCTION)
    LocallyUniqueId
     Pointer to LUID structure receiving new locally unique identifier.
*/
typedef NTSTATUS (NTAPI *_NtAllocateLocallyUniqueId)( OUT PLUID LocallyUniqueId );
 
/*
    NtAllocateUuids (FUNCTION)
    Time
     Returns current time.
*/
typedef NTSTATUS (NTAPI *_NtAllocateUuids)( OUT PLARGE_INTEGER Time, OUT PULONG Range, OUT PULONG Sequence );
 
/*
    NtAllocateVirtualMemory (FUNCTION)
    ProcessHandle
     andle to Process Object opened with PROCESS_VM_OPERATION access.
    *BaseAddress
     f not zero, system tries to allocate virtual memory block on this virtual address. If BaseAddress is zero, system use first free virtual location.
    AllocationType
     an be MEM_RESERVE or MEM_COMMIT.
    Protect
     ne or combination of PAGE_*** attributes.
*/
typedef NTSTATUS (NTAPI *_NtAllocateVirtualMemory)( IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN ULONG ZeroBits, IN OUT PULONG RegionSize, IN ULONG AllocationType, IN ULONG Protect );
 
/*
    NtCallbackReturn (FUNCTION)
    Result
     Pointer to user's allocated buffer with custom data.
    ResultLength
     Length of Result buffer, in bytes.
    Status
     Callback execution status code.
*/
typedef NTSTATUS (NTAPI *_NtCallbackReturn)( IN PVOID Result OPTIONAL, IN ULONG ResultLength, IN NTSTATUS Status );
 
/*
    NtCancelIoFile (FUNCTION)
    FileHandle
     HANDLE to File Object.
    IoStatusBlock
     IO result of call.
*/
typedef NTSTATUS (NTAPI *_NtCancelIoFile)( IN HANDLE FileHandle, OUT PIO_STATUS_BLOCK IoStatusBlock );
 
/*
    NtCancelTimer (FUNCTION)
    TimerHandle
     HANDLE to Timer Object opened with TIMER_MODIFY_STATE access.
    CurrentState
     Pointer to BOOLEAN value, that received state of timer before function call.
*/
typedef NTSTATUS (NTAPI *_NtCancelTimer)( IN HANDLE TimerHandle, OUT PBOOLEAN CurrentState OPTIONAL );
 
/*
    NtClearEvent (FUNCTION)
    INFO-0
     There're no functional difference between NtClearEvent and NtResetEvent, but the first works faster (see NtResetEvent).
*/
typedef NTSTATUS (NTAPI *_NtClearEvent)( IN HANDLE EventHandle );
 
/*
    NtClose (FUNCTION)
    ObjectHandle
     Handle to open object.
*/
typedef NTSTATUS (NTAPI *_NtClose)( IN HANDLE ObjectHandle );
 
/*
    NtCloseObjectAuditAlarm (FUNCTION)
    SubsystemName
     This string is sent to Event Log as the first parameter.
    ObjectHandle
     HANDLE to object, or NULL value.
    GenerateOnClose
     If set, event is generated.
*/
typedef NTSTATUS (NTAPI *_NtCloseObjectAuditAlarm)( IN PUNICODE_STRING SubsystemName, IN HANDLE ObjectHandle OPTIONAL, IN BOOLEAN GenerateOnClose );
 
/*
    NtCompactKeys (FUNCTION)
    INFO-0
     Function NtCompactKeys compacts (reduces size) of specified key(s). On Windows NT the same functionality was given by use NtSaveKey and NtRestoreKey
    NrOfKeys
     Number of enries in KeysArray array.
    KeysArray[]
     Array containing handles for previously opened keys.
    Supported on system versions:
     Win 2000,Win XP/2003
*/
typedef NTSTATUS (NTAPI *_NtCompactKeys)( IN ULONG NrOfKeys, IN HANDLE KeysArray[] );
 
/*
    NtCompleteConnectPort (FUNCTION)
    INFO-0
     Return from NtConnectPort on client's side is synchronised with return from this call. Both sides of LPC connection are ready for sending and receiving LPC messages.
*/
typedef NTSTATUS (NTAPI *_NtCompleteConnectPort)( IN HANDLE PortHandle );
 
/*
    NtCompressKey (FUNCTION)
    INFO-0
     This function compress data associated with specified Key and all his sub-keys. Compressed key require smaller space in registry file, but whole functionality used with compressed key works slower.
    Key
     HANDLE of previously opened key object (with write access).
    Supported on system versions:
     Win 2000,Win XP/2003
*/
typedef NTSTATUS (NTAPI *_NtCompressKey)( IN HANDLE Key );
 
/*
    NtConnectPort (FUNCTION)
    INFO-0
     NtConnectPort is used by client process for establish LPC connection with Named Port's owner.
    ClientPortHandle
     Result of call - HANDLE to Port Object.
    ServerPortName
     Name of port to connect to.
    INFO-3
     SecurityQos
    ClientSharedMemory
     Used when calling process created Section Object for shared memory. See NtAcceptConnectPort for details.
    ServerSharedMemory
     Used when calling process didn't create Section Object. See NtAcceptConnectPort for details.
    MaximumMessageLength
     Maximum communication message length. This value is calculated by server on port creation process (see NtCreatePort).
    ConnectionInfo
     Pointer to RAW buffer containing information from client. That information is received by server through LPC_MESSAGE with MessageType field set to LPC_CONNECTION_REQUEST.
    ConnectionInfoLength
     Size of ConnectionInfo buffer, in bytes.
*/
typedef NTSTATUS (NTAPI *_NtConnectPort)( OUT PHANDLE ClientPortHandle, IN PUNICODE_STRING ServerPortName, IN PSECURITY_QUALITY_OF_SERVICE SecurityQos, IN OUT PLPC_SECTION_OWNER_MEMORY ClientSharedMemory OPTIONAL, OUT PLPC_SECTION_MEMORY ServerSharedMemory OPTIONAL, OUT PULONG MaximumMessageLength OPTIONAL, IN ConnectionInfo OPTIONAL, IN PULONG ConnectionInfoLength OPTIONAL );
 
/*
    NtContinue (FUNCTION)
    You can use NtContinue after processing exception for continue executing thread.
     System uses NtContinue also in APC processing.
*/
typedef NTSTATUS (NTAPI *_NtContinue)( IN PCONTEXT ThreadContext, IN BOOLEAN RaiseAlert );
 
/*
    NtCreateDirectoryObject (FUNCTION)
    DirectoryHandle
     ointer to newly created Directory Object after function call.
    DesiredAccess
     s defined in &lt;ntddk.h&gt; can be one of following:
       #define DIRECTORY_QUERY                 (0x0001)
        #define DIRECTORY_TRAVERSE              (0x0002)
    ObjectAttributes
     ointer to object attributes. Structure must contain valid object name.
*/
typedef NTSTATUS (NTAPI *_NtCreateDirectoryObject)( OUT PHANDLE DirectoryHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes );
 
/*
    NtCreateEvent (FUNCTION)
    EventHandle
     Result of call - HANDLE to newly created Event Object.
    DesiredAccess
     Assess rights associated with created event. Can be one of following values from &lt;winnt.h&gt;:
        EVENT_QUERY_STATE      
        EVENT_MODIFY_STATE
    ObjectAttributes
     Optional name of Event Object for multiprocess use.
    EventType
     See EVENT_TYPE for details.
    InitialState
     State of event immediatelly after creation.
*/
typedef NTSTATUS (NTAPI *_NtCreateEvent)( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState );
 
/*
    NtCreateEventPair (FUNCTION)
    EventPairHandle
     esult handle to EventPair object.
    DesiredAccess
     s defined as:
    INFO-2
     #define EVENT_PAIR_ALL_ACCESS ( STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE )
*/
typedef NTSTATUS (NTAPI *_NtCreateEventPair)( OUT PHANDLE EventPairHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL );
 
/*
    NtCreateFile (FUNCTION)
    INFO-0
     (Avaiable also in 2000 DDK.)
    FileHandle
     Result of call - HANDLE to File Object.
    DesiredAccess
     Access mask based on definitions in schema FILE_* from &lt;WinNT.h&gt;.
    ObjectAttributes
     Name of file to create (or open), optionally path in name string. You can also define root directory, security descriptor and attributes OBJ_CASE_INSENSITIVE and OBJ_INHERIT.
    IoStatusBlock
     Pointer to IO_STATUS_BLOCK structure, that receive final status of function call. Can be one of:
    AllocationSize
     File size after creation.
    FileAttributes
     Attributes for newly created file, as follows:
    INFO-7
        FILE_ATTRIBUTE_READONLY FILE_ATTRIBUTE_HIDDEN   FILE_ATTRIBUTE_SYSTEM   FILE_ATTRIBUTE_ARCHIVE  FILE_ATTRIBUTE_NORMAL   FILE_ATTRIBUTE_TEMPORARY        FILE_ATTRIBUTE_OFFLINE  FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
    ShareAccess
     Specifies share method for opened object. Can be set to zero or any combination of flags:
    INFO-9
        FILE_SHARE_READ         FILE_SHARE_WRITE        FILE_SHARE_DELETE
    CreateDisposition
     Specifies disposition how to create or open object and can be one of:
    INFO-11
        FILE_SUPERSEDE - If file exists, deletes it before creation of new one.         FILE_OPEN - Fails, if file not exists.  FILE_CREATE - Fails, if file exists.    FILE_OPEN_IF - If file exists, opens it. If not, creates new one and then open it.      FILE_OVERWRITE - If file not exists, create and open it. If exists, open them and reset content.        FILE_OVERWRITE_IF - As FILE_OVERWRITE, but fails if file not exists.
    CreateOptions
     Creation options.
    EaBuffer
     Buffer for Extended Attributes contains one or more of FILE_FULL_EA_INFORMATION structures.
    EaLength
     Length of EaBuffer.
*/
typedef NTSTATUS (NTAPI *_NtCreateFile)( OUT PHANDLE FileHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, OUT PIO_STATUS_BLOCK IoStatusBlock, IN PLARGE_INTEGER AllocationSize OPTIONAL, IN ULONG FileAttributes, IN ULONG ShareAccess, IN ULONG CreateDisposition, IN ULONG CreateOptions, IN PVOID EaBuffer OPTIONAL, IN ULONG EaLength );
 
/*
    NtCreateIoCompletion (FUNCTION)
    IoCompletionHandle
     Result of call - HANDLE to newly created IO Completion Object.
    DesiredAccess
     Access mask for created HANDLE. Can be combination of:
        IO_COMPLETION_QUERY_STATE
        IO_COMPLETION_MODIFY_STATE
    ObjectAttributes
     Optionally contains object name, in Objects Namespace.
    NumberOfConcurrentThreads
     Number of threads accessing File Object associated with IO Completion. If Zero, system reserves memory for number of threads equal to current nymber of processes.
*/
typedef NTSTATUS (NTAPI *_NtCreateIoCompletion)( OUT PHANDLE IoCompletionHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN ULONG NumberOfConcurrentThreads );
 
/*
    NtCreateKey (FUNCTION)
    INFO-0
     See ZwCreateKey in NT DDK or 2000 DDK for detailed description.
*/
typedef NTSTATUS (NTAPI *_NtCreateKey)( OUT PHANDLE pKeyHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN ULONG TitleIndex, IN PUNICODE_STRING Class OPTIONAL, IN ULONG CreateOptions, OUT PULONG Disposition OPTIONAL );
 
/*
    NtCreateKeyedEvent (FUNCTION)
    INFO-0
     Synchronization object called KeyedEvent is avaiable in Windows XP+ systems. It's usefull when both (or more) threads have to wait for each other.
    KeyedEventHandle
     HANDLE to newly created KeyedEvent object.
    DesiredAccess
     The same values as for Event objects (typically EVENT_ALL_ACCESS).
    ObjectAttributes
     Optionally name of object.
    Reserved
     Have to be zero. Reserved for future use.
    Supported on system versions:
     Win XP/2003
*/
typedef NTSTATUS (NTAPI *_NtCreateKeyedEvent)( OUT PHANDLE KeyedEventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN ULONG Reserved );
 
/*
    NtCreateMailslotFile (FUNCTION)
    MailslotFileHandle
     Result of call - HANDLE to Mailslot File Object.
    DesiredAccess
     Access rights associated with opened handle.
    ObjectAttributes
     Pointer to OBJECT_ATTRIBUTES structure contains valid object name. Name must be in format "//??/MAILSLOT/..." where "..." means unique name of Mailslot.
    IoStatusBlock
     IO result of call.
    CreateOptions
     Can be combination of:
        FILE_WRITE_THROUGH
        FILE_SYNCHRONOUS_IO_ALERT
    MaxMessageSize
     Maximum message size, or MAILSLOT_SIZE_AUTO for automatic message size.
    ReadTimeOut
     Timeout value, or -1 for infinite waiting.
*/
typedef NTSTATUS (NTAPI *_NtCreateMailslotFile)( OUT PHANDLE MailslotFileHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, OUT PIO_STATUS_BLOCK IoStatusBlock, IN ULONG CreateOptions, IN ULONG MailslotQuota, IN ULONG MaxMessageSize, IN PLARGE_INTEGER ReadTimeOut );
 
/*
    NtCreateMutant (FUNCTION)
    MutantHandle
     esult of function call - handle to newly created Mutant object.
    DesiredAccess
     n most cases there's MUTANT_ALL_ACCESS. See &lt;WinNT.h&gt; or &lt;WinBase.h&gt; for other information about Mutant objects access rights.
    ObjectAttributes
     ay be used to creation named Mutant objects. Named Mutant can be used by more then one process.
    InitialOwner
     f TRUE, Mutant is created with non-signaled state. Caller should call NtReleaseMutant after program initialization.
    <HR WIDTH="40%">
     Mutant object live in object namespace as long as at least one handle is still open. To destroy Mutant, just call NtClose with MutantHandle.
*/
typedef NTSTATUS (NTAPI *_NtCreateMutant)( OUT PHANDLE MutantHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN BOOLEAN InitialOwner );
 
/*
    NtCreateNamedPipeFile (FUNCTION)
    NamedPipeFileHandle
     Result of call - pointer to HANDLE to Named Pipe.
    DesiredAccess
     Access rights for object's handle. Can be one or combination of:FILE_READ_DATAFILE_WRITE_DATAFILE_CREATE_PIPE_INSTANCEFILE_READ_ATTRIBUTESFILE_WRITE_ATTRIBUTESSYNCHRONIZEREAD_CONTROLWRITE_OWNERWRITE_DACACCESS_SYSTEM_SECURITY
    ObjectAttributes
     Pointer to OBJECT_ATTRIBUTES structure contains name of named pipe. Name must begin with "/??/PIPE/" string, that is Symbolic Link to NamedPipe device object.
    IoStatusBlock
     IO result of call.
    ShareAccess
     Can be combination of following:FILE_SHARE_READFILE_SHARE_WRITEFILE_SHARE_DELETE
    CreateDisposition
     Use FILE_CREATE, FILE_OPEN or FILE_OPEN_IF.
    CreateOptions
     See description of NtCreateFile for possible creation flags.
    WriteModeMessage
     If set, writing to created pipe are processed in Message Mode. If not, all writes are in Byte Mode.
    ReadModeMessage
     The same functionality as WriteModeMessage parameter, but for reading data.
    NonBlocking
     If set, all operations on created pipe are asynchronous.
    MaxInstances
     Maximum number of open handles for Named Pipe, or FILE_PIPE_UNLIMITED_INSTANCES constant.
    InBufferSize
     Input buffer size, in bytes.
    OutBufferSize
     Output buffer size, in bytes.
    DefaultTimeOut
     Pointer to LARGE_INTEGER value specifing pipe's time out, in 100-ns units. Negative value means relative time.
*/
typedef NTSTATUS (NTAPI *_NtCreateNamedPipeFile)( OUT PHANDLE NamedPipeFileHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, OUT PIO_STATUS_BLOCK IoStatusBlock, IN ULONG ShareAccess, IN ULONG CreateDisposition, IN ULONG CreateOptions, IN BOOLEAN WriteModeMessage, IN BOOLEAN ReadModeMessage, IN BOOLEAN NonBlocking, IN ULONG MaxInstances, IN ULONG InBufferSize, IN ULONG OutBufferSize, IN PLARGE_INTEGER DefaultTimeOut );
 
/*
    NtCreatePagingFile (FUNCTION)
    PageFileName
     System path to newly created paged file.
    MiniumSize
     Minimum size of paged file, in bytes. This value must be multiply of page size (0x1000 bytes on x86), and must be greater then 2MB (0x02000000 bytes).
    MaxiumSize
     Maximum size of paged file, in bytes. Also this value must be multiply of page size. Minimal value accepted is 5MB (0x05000000 bytes).
    ActualSize
     Optional (and currently unused) parameter.
*/
typedef NTSTATUS (NTAPI *_NtCreatePagingFile)( IN PUNICODE_STRING PageFileName, IN PLARGE_INTEGER MiniumSize, IN PLARGE_INTEGER MaxiumSize, OUT PLARGE_INTEGER ActualSize OPTIONAL );
 
/*
    NtCreatePort (FUNCTION)
    PortHandle
     Result of call - HANDLE to Port Object.
    ObjectAttributes
     Typically contains name and SECURITY_DESCRIPTOR for newly created named port.
    INFO-2
     MaxConnectInfoLength
    MaxDataLength
     Maximum size of message.
    INFO-4
     Reserved
*/
typedef NTSTATUS (NTAPI *_NtCreatePort)( OUT PHANDLE PortHandle, IN POBJECT_ATTRIBUTES ObjectAttributes, IN ULONG MaxConnectInfoLength, IN ULONG MaxDataLength, IN OUT PULONG Reserved OPTIONAL );
 
/*
        NtCreateProcess (FUNCTION)
    INFO-0
*/
typedef NTSTATUS (NTAPI *_NtCreateProcess)( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ParentProcess, IN BOOLEAN InheritObjectTable, IN HANDLE SectionHandle OPTIONAL, IN HANDLE DebugPort OPTIONAL, IN HANDLE ExceptionPort OPTIONAL );
 
/*
    NtCreateProfile (FUNCTION)
    ProfileHandle
     Result of call - HANDLE to Profile Object.
    Process
     HANDLE to Process Object to profile. Not required if profiled code is placed in Kernel address space (above 0x80000000).
    ImageBase
     Start address of profiling.
    ImageSize
     Size of profiled memory block.
    Buffer
     Caller's allocated buffer for data.
    BufferSize
     Size of buffer, in bytes.
    ProfileSource
     Identifier of performance counter. See KPROFILE_SOURCE enumeration type for possible values.
    Affinity
     Processor affinity mask. It defines processors to ask about performance counter.
*/
typedef NTSTATUS (NTAPI *_NtCreateProfile)( OUT PHANDLE ProfileHandle, IN HANDLE Process OPTIONAL, IN PVOID ImageBase, IN ULONG ImageSize, IN ULONG BucketSize, IN PVOID Buffer, IN ULONG BufferSize, IN KPROFILE_SOURCE ProfileSource, IN KAFFINITY Affinity );
 
/*
    NtCreateSection (FUNCTION)
    SectionHandle
     Result of call - HANDLE to Section Object.
    DesiredAccess
     Access mask. Can be combination of:
        SECTION_QUERY      
        SECTION_MAP_WRITE  
    ObjectAttributes
     Pointer to OBJECT_ATTRIBUTES structure contains section name, in Object Namespace format.
    MaximumSize
     Optionally define maximum size of section. Must be defined when caller create section based on system PageFile.
    PageAttributess
     Can be one or combination of:
        PAGE_NOACCESS        
        PAGE_READONLY        
    SectionAttributes
     Can be one or combination of:
        SEC_FILE  
        SEC_IMAGE  
    FileHandle
     Optionally HANDLE to File Object opened with proper access.
*/
typedef NTSTATUS (NTAPI *_NtCreateSection)( OUT PHANDLE SectionHandle, IN ULONG DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN PLARGE_INTEGER MaximumSize OPTIONAL, IN ULONG PageAttributess, IN ULONG SectionAttributes, IN HANDLE FileHandle OPTIONAL );
 
/*
    NtCreateSemaphore (FUNCTION)
    SemaphoreHandle
     Result of call - pointer to HANDLE to Semaphore Object.
    DesiredAccess
     Access rights to Semaphore Object. Can be one of:
        SEMAPHORE_QUERY_STATE
        SEMAPHORE_MODIFY_STATE
    ObjectAttributes
     Optional pointer to OBJECT_ATTRIBUTES structure containing semaphore's name.
    InitialCount
     Initial state of semaphore. Typically the same as MaximumCount.
    MaximumCount
     Maximum releases number.
*/
typedef NTSTATUS (NTAPI *_NtCreateSemaphore)( OUT PHANDLE SemaphoreHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN ULONG InitialCount, IN ULONG MaximumCount );
 
/*
    NtCreateSymbolicLinkObject  (FUNCTION)
    pHandle
     Handle to SymbolicLinkObject.
    INFO-1
     
    ObjectAttributes
     Name of SymbolicLinkObject.
    DestinationName
     Name or path to destination object in Object Namespace.
*/
typedef NTSTATUS NTAPI NtCreateSymbolicLinkObject )( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName );
 
/*
    NtCreateThread (FUNCTION)
    ThreadHandle
     DIV CLASS="reg">Caller supplied storage for the resulting handle.
    DesiredAccess
     DIV CLASS="reg">Specifies the allowed or desired access to the thread.
    ObjectAttributes
     DIV CLASS="reg">Initialized attributes for the object.
    ProcessHandle
     DIV CLASS="reg">Handle to the threads parent process.
    ClientId
     DIV CLASS="reg">Caller supplies storage for returned process id and thread id.
    ThreadContext
     DIV CLASS="reg">Initial processor context for the thread.
    InitialTeb
     DIV CLASS="reg">Initial user mode stack context for the thread.
    CreateSuspended
     DIV CLASS="reg">Specifies if the thread is ready for scheduling. See NtContinue for more information.
*/
typedef NTSTATUS (NTAPI *_NtCreateThread)( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, OUT PCLIENT_ID ClientId, IN PCONTEXT ThreadContext, IN PINITIAL_TEB InitialTeb, IN BOOLEAN CreateSuspended );
 
/*
    NtCreateTimer (FUNCTION)
    TimerHandle
     Result of call - HANDLE to Timer Object.
    DesiredAccess
     Access mask for TimerHandle. Can be set of (from &lt;WinNT.h&gt;):
    ObjectAttributes
     Optional name of Timer Object.
    TimerType
     Can be NotificationTimer or SynchronizationTimer (enumerated type definition from &lt;ntdef.h&gt;).
*/
typedef NTSTATUS (NTAPI *_NtCreateTimer)( OUT PHANDLE TimerHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN TIMER_TYPE TimerType );
 
/*
    NtCreateToken (FUNCTION)
    TokenHandle
     Result of call - pointer to HANDLE to Token Object.
    DesiredAccess
     Can be one or more of following:
        TOKEN_ASSIGN_PRIMARY
        TOKEN_DUPLICATE
    ObjectAttributes
     Pointer to OBJECT_ATTRIBUTES structure.
    TokenType
     (?), see TOKEN_TYPE enumeration type.
    AuthenticationId
     (?), see NtAllocateLocallyUniqueId security function.
    ExpirationTime
     (?), pointer to LARGE_INTEGER value contains time in 100-ns format.
    TokenUser
     (?), see TOKEN_USER structure.
    TokenGroups
     (?), see TOKEN_GROUPS structure.
    TokenPrivileges
     (?), see TOKEN_PRIVILEGES structure.
    TokenOwner
     (?), see TOKEN_OWNER structure.
    TokenPrimaryGroup
     (?), see TOKEN_PRIMARY_GROUP structure.
    TokenDefaultDacl
     (?), see TOKEN_DEFAULT_DACL structure.
    TokenSource
     (?), see TOKEN_SOURCE structure.
*/
typedef NTSTATUS (NTAPI *_NtCreateToken)( OUT PHANDLE TokenHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN TOKEN_TYPE TokenType, IN PLUID AuthenticationId, IN PLARGE_INTEGER ExpirationTime, IN PTOKEN_USER TokenUser, IN PTOKEN_GROUPS TokenGroups, IN PTOKEN_PRIVILEGES TokenPrivileges, IN PTOKEN_OWNER TokenOwner, IN PTOKEN_PRIMARY_GROUP TokenPrimaryGroup, IN PTOKEN_DEFAULT_DACL TokenDefaultDacl, IN PTOKEN_SOURCE TokenSource );
 
/*
    NtCurrentTeb (FUNCTION)
    INFO-0
     NtCurrentTeb isn't typical NT CALL realised via INT 2E, becouse TEB is accessable at address fs:[0018h].
    INFO-1
     Microsoft declare NtCurrentTeb as __cdecl, but ntdll.dll export it as __stdcall (it don't have metter, becouse function don't have any parameters), so you cannot use ntdll.dll export. In this case the better way is write NtCurrentTeb manually, declaring it as __cdecl.
*/
typedef PTEB (NTAPI *_NtCurrentTeb)( );
 
/*
    NtDelayExecution (FUNCTION)
    Alertable
     If set, execution can break in a result of NtAlertThread call.
    DelayInterval
     Delay in 100-ns units. Negative value means delay relative to current.
*/
typedef NTSTATUS (NTAPI *_NtDelayExecution)( IN BOOLEAN Alertable, IN PLARGE_INTEGER DelayInterval );
 
/*
    NtDeleteAtom (FUNCTION)
    Atom
     Atom identifier.
*/
typedef NTSTATUS (NTAPI *_NtDeleteAtom)( IN RTL_ATOM Atom );
 
/*
    NtDeleteFile (FUNCTION)
    It's very interesting NT System Call... Normally, file deletion is realised as FileDispositionInformation class in a call to NtSetInformationFile. When you use NtDeleteFile, file will be deleted immediatly after call (system isn't waiting for close last HANDLE to file).
     <HR WIDTH="40%">
    ObjectAttributes
     ou can manipulate ObjectName and RootDirectory members.
*/
typedef NTSTATUS (NTAPI *_NtDeleteFile)( IN POBJECT_ATTRIBUTES ObjectAttributes );
 
/*
    NtDeleteKey (FUNCTION)
    INFO-0
     See ZwDeleteKey in NT DDK or 2000 DDK for detailed description.
*/
typedef NTSTATUS (NTAPI *_NtDeleteKey)( IN HANDLE KeyHandle );
 
/*
    NtDeleteObjectAuditAlarm (FUNCTION)
    SubsystemName
     This string is passed as a parameter to event message.
    ObjectHandle
     HANDLE to any object.
    GenerateOnClose
     If set, event is generated.
*/
typedef NTSTATUS (NTAPI *_NtDeleteObjectAuditAlarm)( IN PUNICODE_STRING SubsystemName, IN HANDLE ObjectHandle OPTIONAL, IN BOOLEAN GenerateOnClose );
 
/*
    NtDeleteValueKey (FUNCTION)
    INFO-0
*/
typedef NTSTATUS (NTAPI *_NtDeleteValueKey)( IN HANDLE KeyHandle, IN PUNICODE_STRING ValueName );
 
/*
    NtDeviceIoControlFile (FUNCTION)
    FileHandle
     HANDLE to Device Object opened as a file.
    Event
     Optional HANDLE to Event Object signalled on the end of processing request.
    ApcRoutine
     Optional pointer to user's APC Routine called on the end of processing request.
    ApcContext
     User's parameter to ApcRoutine.
    IoStatusBlock
     IO result of call.
    IoControlCode
     IO Control code [IOCTL_*].
    InputBuffer
     User's allocated buffer with input data.
    InputBufferLength
     Length of InputBuffer, in bytes.
    OutputBuffer
     User's allocated buffer for result data.
    OutputBufferLength
     Length of OutputBuffer, in bytes.
*/
typedef NTSTATUS (NTAPI *_NtDeviceIoControlFile)( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, IN ULONG IoControlCode, IN PVOID InputBuffer OPTIONAL, IN ULONG InputBufferLength, OUT PVOID OutputBuffer OPTIONAL, IN ULONG OutputBufferLength );
 
/*
    NtDisplayString (FUNCTION)
    String
     Pointer to UNICODE_STRING contains string to display. Some basic control characters are implemented (like CR, LF).
*/
typedef NTSTATUS (NTAPI *_NtDisplayString)( IN PUNICODE_STRING String );
 
/*
    NtDuplicateObject (FUNCTION)
    INFO-0
     See Microsoft SDK for description of DuplicateHandle Win32 API.
*/
typedef NTSTATUS (NTAPI *_NtDuplicateObject)( IN HANDLE SourceProcessHandle, IN PHANDLE SourceHandle, IN HANDLE TargetProcessHandle, OUT PHANDLE TargetHandle, IN ACCESS_MASK DesiredAccess OPTIONAL, IN BOOLEAN InheritHandle, IN ULONG Options );
 
/*
    NtDuplicateToken (FUNCTION)
    ExistingToken
     HANDLE to Token Object opened with TOKEN_DUPLICATE access.
    DesiredAccess
     Access mask for newly created token. Can be combination of:
        TOKEN_ASSIGN_PRIMARY
        TOKEN_DUPLICATE
    ObjectAttributes
     Optionally pointer to OBJECT_ATTRIBUTES structure, containing token's name.
    ImpersonationLevel
     Level of impersonation for new token.
    TokenType
     Type of new token.
    NewToken
     Result of call - pointer to HANDLE to new Token Object.
*/
typedef NTSTATUS (NTAPI *_NtDuplicateToken)( IN HANDLE ExistingToken, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, IN TOKEN_TYPE TokenType, OUT PHANDLE NewToken );
 
/*
    NtEnumerateKey (FUNCTION)
    INFO-0
     See ZwEnumerateKey in NT DDK or 2000 DDK for detailed description.
*/
typedef NTSTATUS (NTAPI *_NtEnumerateKey)( IN HANDLE KeyHandle, IN ULONG Index, IN KEY_INFORMATION_CLASS KeyInformationClass, OUT PVOID KeyInformation, IN ULONG Length, OUT PULONG ResultLength );
 
/*
    NtEnumerateValueKey (FUNCTION)
    INFO-0
     See ZwEnumerateValueKey in NT DDK or 2000 DDK for detailed description.
*/
typedef NTSTATUS (NTAPI *_NtEnumerateValueKey)( IN HANDLE KeyHandle, IN ULONG Index, IN KEY_VALUE_INFORMATION_CLASS KeyValueInformation, OUT PVOID KeyValueInformation, IN ULONG Length, OUT PULONG ResultLength );
 
/*
    NtExtendSection (FUNCTION)
    SectionHandle
     Must be open with SECTION_EXTEND_SIZE attribute.
*/
typedef NTSTATUS (NTAPI *_NtExtendSection)( IN HANDLE SectionHandle, IN PLARGE_INTEGER NewSectionSize );
 
/*
    NtFindAtom (FUNCTION)
    AtomName
     Atom's name, in UNICODE format.
    Atom
     Result of call - Pointer to Atom's identifier.
*/
typedef NTSTATUS (NTAPI *_NtFindAtom)( IN PWCHAR AtomName, OUT PRTL_ATOM Atom OPTIONAL );
 
/*
    NtFlushBuffersFile (FUNCTION)
    FileHandle
     HANDLE to File Object.
    IoStatusBlock
     IO result of call.
*/
typedef
